# LOG710 Deadlock Algorithms
This repository contains algorithms taught in course
[LOG710 *Principes des systèmes d’exploitation et programmation système*](https://www.etsmtl.ca/etudes/cours/LOG710)
in *École de technologie supérieure* (ÉTS), in Montreal. Their purpose is to
detect the deadlocks between processes running on an operating system and to
prevent them.

This implementation of those algorithms is only a **simulation**: an operating
system cannot use it to control deadlocks. Its only use is to observe their
steps and results.

Three classes in this repository, *DeadlockDetector*, *RequestEvaluator* and
*SafeSequenceMaker*, contain a method *main*. They will be used to generate
runnable .jar files to call in command line with the path to a data file as a
parameter. This file’s extension must be “.txt”. Those runnable files create a
result file in their directory. The result file’s extension is also “.txt”.

The first line in the data file indicates the number of processes considered
(n); the second line indicates the number of resource types (m) that they may
access. The data file and the result file contain matrices of n rows by m
columns associating data with a process (row index, the first one) and a
resource type (column index, the second one). They also contain row matrices
whose meaning is stated further into this document. The numbers on the same
line in a matrix are separated by spaces. It is paramount that n and m be
consistent with the matrices’ dimensions. Their indices start at 0. All
matrices, given and calculated, may only contain natural integers.

File [06-deadlocks.pdf](/06-deadlocks.pdf) contains an explaination of
deadlocks, a statement of the algorithms in this repository and examples of
their application.

## Detecting Deadlocks
Create a runnable .jar file from class *DeadlockDetector* and name it
deadlock_detector.jar. Run it in command line and give it the path to a data
file as a parameter. For example, on Windows, deadlock_detector.jar can be
called with the data files provided in this repository in the following
manner.

```
java -jar .\deadlock_detector.jar .\deadlock_detection1.txt
java -jar .\deadlock_detector.jar .\deadlock_detection2.txt
java -jar .\deadlock_detector.jar .\deadlock_detection3.txt
java -jar .\deadlock_detector.jar .\deadlock_detection4.txt
java -jar .\deadlock_detector.jar .\deadlock_detection5.txt
java -jar .\deadlock_detector.jar .\deadlock_detection6.txt
```

The data file defines matrices *Resources*, *Allocation* and *Request*. Row
matrix *Resources* indicates the number of resources of each type involved in
the simulation. Matrix *Allocation* indicates the number of resources of each
type initially allocated to each process. Matrix *Request* indicates the
number of resources that each process requests from the system. The data file
provided to deadlock_detector.jar must be conform to the following format,
where “xi,j” is a natural integer x at coordinates (i, j) in a matrix.

```
Processes: n
Resource types: m

Resources
x0,0 x0,1 x0,2 … x0,m-1

Allocation
x0,0 x0,1 x0,2 … x0,m-1
x1,0 x1,1 x1,2 … x1,m-1
x2,0 x2,1 x2,2 … x2,m-1
…
xn-1,0 xn-1,1 xn-1,2 … xn-1,m-1

Request
x0,0 x0,1 x0,2 … x0,m-1
x1,0 x1,1 x1,2 … x1,m-1
x2,0 x2,1 x2,2 … x2,m-1
…
xn-1,0 xn-1,1 xn-1,2 … xn-1,m-1
```

In the result file, row matrix *Available* indicates the number of available
resources of each type. At the begining, each of its cells (0, j) contains the
difference between cell (0, j) of *Resources* and the sum of *Allocation*’s
column j. *Finish* is an array of n Booleans indicating whether a process has
been executed (true) or not (false). Initially, all its elements are false.
Row matrix *Work*, of length m, is data that is checked in the deadlock
detection algorithm.

The deadlock detection algorithm is presented in
[06-deadlocks.pdf](/06-deadlocks.pdf)
at pages 25 and 26.

## Preventing Deadlocks
Classes *RequestEvaluator* and *SafeSequenceMaker* run the banker’s algorithm
to determine whether allocating the resources requested by a process would put
the system in an unsafe state. The system’s state is safe if and only if it
can avoid deadlocks; if its state is unsafe, deadlocks are possible, but not
certain. *RequestEvaluator* and *SafeSequenceMaker* need data files conform to
the following format. Files deadlock_prevention1.txt to
deadlock_prevention3.txt are valid input examples.

```
Processes: n
Resource types: m

Resources
x0,0 x0,1 x0,2 … x0,m-1

Allocation
x0,0 x0,1 x0,2 … x0,m-1
x1,0 x1,1 x1,2 … x1,m-1
x2,0 x2,1 x2,2 … x2,m-1
…
xn-1,0 xn-1,1 xn-1,2 … xn-1,m-1

Maximum
x0,0 x0,1 x0,2 … x0,m-1
x1,0 x1,1 x1,2 … x1,m-1
x2,0 x2,1 x2,2 … x2,m-1
…
xn-1,0 xn-1,1 xn-1,2 … xn-1,m-1
```

This format is identical to the one prescribed for deadlock detection except
that it demands a matrix *Maximum* rather than *Request*. *Maximum* indicates
the number of resources of each type that a process may request from the
operating system.

In the result file generated by *RequestEvaluator* and *SafeSequenceMaker*,
matrix *Available* has the same meaning as the one calculated by
*DeadlockDetector*. Matrix *Need* indicates the number of supplementary
resources that a process may need. Row matrix *Work*, of length m, is data
meant to be checked in the banker’s algorithm.

The safe state is defined in [06-deadlocks.pdf](/06-deadlocks.pdf) at page 42.
Pages 47 to 49 present the banker’s algorithm and the resource request
algorithm. Geeks for Geeks also descibes them
[here](https://www.geeksforgeeks.org/bankers-algorithm-in-operating-system-2/).

### Evaluating Requests
Create a runnable .jar file from class *RequestEvaluator* and name it
request_evaluator.jar. Run it in command line with the path to a data file as
the first parameter and, as the second parameter, a string of characters,
whose case will not matter, expressing a Boolean value. This last parameter
determines whether the result file will contain detailed data from the
banker’s algorithm. For the value *false*, the following strings are accepted:
"0", "f", "false", "n", "no"; for the value *true*, enter one of these
strings: "1", "t", "true", "y", "yes". On Windows, request_evaluator.jar can
be run the following way.

```
java -jar .\request_evaluator.jar .\deadlock_prevention1.txt 0
java -jar .\request_evaluator.jar .\deadlock_prevention2.txt y
java -jar .\request_evaluator.jar .\deadlock_prevention3.txt f
java -jar .\request_evaluator.jar .\deadlock_prevention4.txt 1
```

First, the program indicates in the console whether the system’s initial state
is safe or not. Then, it asks the user to enter the number of a process (from
0 to n-1, like the matrices’ row indices) and a resource request for that
process. The input must consist of a sequence of natural integers separated by
spaces. The first is the process number; the next are the numbers of requested
resources of each type. If the request does not create an unsafe state, the
program asks the user if they want to execute the process. It they do, the
matrices representing the system’s state are updated accordingly. This use
sequence will repeat until the user enters “q” instead of a request.

In the next example, the user makes the following requests:
1. For process 1
	* 1 resource of type 0
	* 0 resource of type 1
	* 2 resources of type 2
2. For process 4
	* 3 resources of type 0
	* 3 resources of type 1
	* 0 resource of type 2
3. For process 0
	* 0 resource of type 0
	* 2 resources of type 1
	* 0 resource of type 2

```
The system's initial state is safe.

Process and request ("q" to quit): 1 1 0 2
Process 1 can be executed.
Do you want to execute it? n

Process and request ("q" to quit): 4 3 3 0
Executing process 4 would put the system in an unsafe state.

Process and request ("q" to quit): 0 0 2 0
Process 0 can be executed.
Do you want to execute it? n

Process and request ("q" to quit): q
```

The result file produced when the program ends contains the text from the
console and data related to the system’s state and the banker’s algorithm.
This data is more detailed if the second parameter in the command line is
true.

### Making a Safe Sequence
A safe sequence is a sequence of processes that can be executed in the order
defined by the sequence without a deadlock occurring. An operating system is
in a safe state if and only if at least one safe sequence exists.

Create a runnable .jar file from class *SafeSequenceMaker* and name it
safe_sequence_maker.jar. Run it in command line with the path to a data file
as the only parameter as shown below.

```
java -jar .\safe_sequence_maker.jar .\deadlock_prevention1.txt
java -jar .\safe_sequence_maker.jar .\deadlock_prevention2.txt
java -jar .\safe_sequence_maker.jar .\deadlock_prevention3.txt
```

This program executes the banker’s algorithm. Its result file contains, for
each iteration, detailed data from the algorithm, the same as the data
recorded by request_evaluator.jar if its second parameter is true, and the
safe sequence determined by the current iteration and the previous ones. The
algorithm ends when it has made a safe sequence including all processes or
determined that it is impossible. In the latter case, a message tells it.
